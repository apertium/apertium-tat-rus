<?xml version="1.0" encoding="UTF-8"?>
<!-- -*- nxml -*- -->

<!-- Tests are run by './qa.sh t1x' command.
     INPUT is the output of lexical selection,
     OUTPUT is the expected output of this transfer module.

     Also make sure to run './qa.sh' (with no arguments)
     before committing to svn. -->

<transfer default="chunk">

  <section-def-cats>

    <def-cat n="n">
      <cat-item tags="n"/>
      <cat-item tags="n.*"/>
      <cat-item tags="prn.*"/>
      <cat-item tags="np.*"/>
      <cat-item tags="adj.subst"/>
      <cat-item tags="adj.subst.*"/>
      <cat-item tags="adj.comp.subst"/>
      <cat-item tags="adj.comp.subst.*"/>
      <cat-item tags="v.*.ger.*"/>
    </def-cat>
    <def-cat n="n-gen">
      <cat-item tags="n.gen"/>
      <cat-item tags="np.*.*.gen"/>
    </def-cat>
    <def-cat n="n-loc">
      <cat-item tags="n.loc"/>
      <cat-item tags="n.pl.loc"/>
    </def-cat>
    <def-cat n="n-px3sp-nom">
      <cat-item tags="n.px3sp.nom"/>
    </def-cat>
    <def-cat n="n-px3sp">
      <cat-item tags="n.px3sp.*"/>
      <cat-item tags="n.pl.px3sp.*"/>
      <cat-item tags="v.*.ger.px3sp.*"/>
      <cat-item tags="v.*.ger.pl.px3sp.*"/>
    </def-cat>
    <def-cat n="n-px">
      <cat-item tags="n.px1sg.*"/>
      <cat-item tags="n.*.px1sg.*"/>
      <cat-item tags="n.px2sg.*"/>
      <cat-item tags="n.*.px2sg.*"/>
      <cat-item tags="n.px3sp.*"/>
      <cat-item tags="n.*.px3sp.*"/>
      <cat-item tags="n.px1pl.*"/>
      <cat-item tags="n.*.px1pl.*"/>
      <cat-item tags="n.px2pl.*"/>
      <cat-item tags="n.*.px2pl.*"/>
    </def-cat>
    <def-cat n="n-attr-or-gen">
      <cat-item tags="n.attr"/>
      <cat-item tags="n.gen"/>
      <cat-item tags="n.pl.gen"/>
      <cat-item tags="np.*.gen"/>
      <cat-item tags="np.ant.*.nom"/> <!-- no attr reading provided by lexc -->
      <cat-item tags="np.ant.*.gen"/> 
      <cat-item tags="np.cog.*.nom"/> <!-- no attr reading provided by lexc -->
      <cat-item tags="np.cog.*.gen"/> 
    </def-cat>
    <def-cat n="npost">
      <cat-item lemma="алд" tags="n.px3sp.loc"/>
      <cat-item lemma="арт" tags="n.px3sp.loc"/>
      <cat-item lemma="ян" tags="n.px3sp.loc"/>
    </def-cat>
    <def-cat n="npost-attr">
      <cat-item lemma="алд" tags="n.px3sp.loc.attr"/>
    </def-cat>

    <def-cat n="prn-gen">
      <cat-item tags="prn.pers.*.*.gen"/>
      <cat-item lemma="ул" tags="prn.dem.gen"/>
      <cat-item lemma="ул" tags="prn.dem.pl.gen"/> 
   </def-cat>

    <def-cat n="adj">
      <cat-item tags="adj"/>
      <cat-item tags="adj.comp"/>
    </def-cat>

    <def-cat n="yuq-adj">
      <cat-item lemma="юк" tags="adj"/>
    </def-cat>

    <def-cat n="det">
      <cat-item tags="det.*"/>
    </def-cat>

    <def-cat n="num">
      <cat-item tags="num"/>
      <cat-item tags="num.*"/>
    </def-cat>

    <def-cat n="cop-p3">
      <cat-item tags="cop.p3.sg"/>
      <cat-item tags="cop.p3.pl"/>
    </def-cat>
    <def-cat n="cop-pres">
      <cat-item tags="cop.p1.*"/>
      <cat-item tags="cop.p2.*"/>
      <cat-item tags="cop.p3.*"/>
      <cat-item tags="cop.neg.p3.*"/>
    </def-cat>
    <def-cat n="cop-ifi">
      <cat-item tags="cop.ifi.*.*"/>
    </def-cat>

    <def-cat n="verb-fin">
      <cat-item tags="v.*.pres.*"/>
      <cat-item tags="v.*.*.pres.*"/>
      <cat-item tags="vaux.pres.*"/>
      <cat-item tags="vaux.neg.pres.*"/>
      <cat-item tags="v.*.ifi.*"/>
      <cat-item tags="v.*.*.ifi.*"/>
      <cat-item tags="vaux.ifi.*"/>
      <cat-item tags="vaux.neg.ifi.*"/>
      <cat-item tags="v.*.past.*"/>
      <cat-item tags="v.*.*.past.*"/>
      <cat-item tags="vaux.past.*"/>
      <cat-item tags="vaux.neg.past.*"/>
      <cat-item tags="v.*.imp.*"/>
      <cat-item tags="v.*.*.imp.*"/>
    </def-cat>
    <def-cat n="verb-nonfin">
      <cat-item tags="v.*.inf"/>
      <cat-item tags="v.*.*.inf.*"/>
      <cat-item tags="v.*.prc_perf"/>
      <cat-item tags="v.*.*.prc_perf"/>
      <cat-item tags="v.*.prc_impf"/>
      <cat-item tags="v.*.*.prc_impf"/>
      <cat-item tags="v.*.gna_perf"/>
      <cat-item tags="v.*.*.gna_perf"/>
      <cat-item tags="v.*.gna_impf"/>
      <cat-item tags="v.*.*.gna_impf"/>
      <cat-item tags="v.*.prc_fut"/>
      <cat-item tags="v.*.*.prc_fut"/>
      <cat-item tags="v.*.prc_fut"/>
      <cat-item tags="v.*.*.prc_fut"/>
      <cat-item tags="v.*.prc_vol_"/>
      <cat-item tags="v.*.ger_past.*"/>
      <cat-item tags="v.*.*.ger_past.*"/>
      <cat-item tags="cop.ger_past.*"/>
      <cat-item tags="cop.*.ger_past.*"/>
      <cat-item tags="v.*.gpr_past"/>
      <cat-item tags="v.*.*.gpr_past"/>
      <cat-item tags="v.*.gpr_past.*"/>
      <cat-item tags="v.*.*.gpr_past.*"/>
      <cat-item tags="v.*.gpr_fut.*"/>
      <cat-item tags="v.*.*.gpr_fut.*"/>
      <cat-item tags="v.*.gpr_fut"/>
      <cat-item tags="v.*.*.gpr_fut"/>
      <cat-item tags="v.*.gpr_fut3"/>
      <cat-item tags="v.*.*.gpr_fut3"/>
      <cat-item tags="v.*.gna_after"/>
      <cat-item tags="v.*.*.gna_after"/>
      <cat-item tags="vaux.gna_after"/>
      <cat-item tags="vaux.*.gna_after"/>
      <cat-item tags="v.*.gna_cond.*"/>
      <cat-item tags="v.*.*.gna_cond.*"/>
    </def-cat>

    <def-cat n="qst">
      <cat-item tags="qst"/>
    </def-cat>
    <def-cat n="sent">
      <cat-item tags="sent"/>
    </def-cat>
    <def-cat n="cm">
      <cat-item tags="cm"/>
    </def-cat>

    <def-cat n="post">
      <cat-item tags="post"/>
    </def-cat>

  </section-def-cats>

  <section-def-attrs>
    <def-attr n="a_pos">
      <attr-item tags="adj"/>
      <attr-item tags="n"/>
      <attr-item tags="np"/>
      <attr-item tags="np.cog"/>
      <attr-item tags="pred"/>
      <attr-item tags="pr"/>
    </def-attr>
    <def-attr n="a_syn">
      <attr-item tags="advl"/>
      <attr-item tags="attr"/>
      <attr-item tags="subst"/>
    </def-attr>
    <def-attr n="a_nom">
      <attr-item tags="n"/>
      <attr-item tags="np.ant"/>
      <attr-item tags="np.top"/>
      <attr-item tags="np.cog"/>
      <attr-item tags="prn.pers.p1"/>
      <attr-item tags="prn.pers.p2"/>
      <attr-item tags="prn.pers.p3"/>
      <attr-item tags="prn.dem"/>
      <attr-item tags="prn.itg"/>
      <attr-item tags="prn.neg"/>
      <attr-item tags="adj"/>
    </def-attr>
    <def-attr n="a_det">
      <attr-item tags="det.dem"/>
      <attr-item tags="det.pos"/>
      <attr-item tags="det.itg"/>
      <attr-item tags="det.ind"/>
      <attr-item tags="num"/>
    </def-attr>
    <def-attr n="a_num">
      <attr-item tags="num"/>
    </def-attr>

    <def-attr n="a_adj">
      <attr-item tags="adj"/>
      <attr-item tags="adj.sint"/>
    </def-attr>
    <def-attr n="a_digit">
      <attr-item tags="digit"/>
    </def-attr>
    <def-attr n="a_adv">
      <attr-item tags="adv"/>
    </def-attr>
    <def-attr n="a_pr">
      <attr-item tags="pr"/>
    </def-attr>
    <def-attr n="a_vbser">
      <attr-item tags="vbser"/>
    </def-attr>
    <def-attr n="a_vblex">
      <attr-item tags="vblex.impf"/>
      <attr-item tags="vblex.perf"/>
      <attr-item tags="vbmod.impf.tv"/> <!-- Modal verbs already receive transitivity tags in rus.dix-->
      <attr-item tags="vbmod.impf.iv"/>
      <attr-item tags="vbmod.perf.tv"/>
      <attr-item tags="vbmod.perf.iv"/>
    </def-attr>
    <def-attr n="a_gender">
      <attr-item tags="m"/>
      <attr-item tags="f"/>
      <attr-item tags="nt"/>
      <attr-item tags="mf"/>
      <attr-item tags="mfn"/>
    </def-attr>
    <def-attr n="a_anim">
      <attr-item tags="aa"/>
      <attr-item tags="nn"/>
      <attr-item tags="an"/>
    </def-attr>
    <def-attr n="a_poss">
      <attr-item tags="px1sg"/>
      <attr-item tags="px2sg"/>
      <attr-item tags="px3sp"/>
      <attr-item tags="px1pl"/>
      <attr-item tags="px2pl"/>
    </def-attr>
    <def-attr n="a_case">
      <attr-item tags="nom"/>
      <attr-item tags="gen"/>
      <attr-item tags="dat"/>
      <attr-item tags="acc"/>
      <attr-item tags="abl"/>
      <attr-item tags="loc"/>
      <attr-item tags="sim"/>
      <attr-item tags="ins"/>
      <attr-item tags="prp"/>
      <attr-item tags="CD"/>
    </def-attr>
    <def-attr n="a_px">
      <attr-item tags="px"/>
    </def-attr>
    <def-attr n="a_nbr">
      <attr-item tags="sg"/>
      <attr-item tags="pl"/>
    </def-attr>
    <def-attr n="a_pers">
      <attr-item tags="p1"/>
      <attr-item tags="p2"/>
      <attr-item tags="p3"/>
    </def-attr>
    <def-attr n="a_tense">
      <attr-item tags="pres"/>
      <attr-item tags="ifi"/>
      <attr-item tags="past"/>
      <attr-item tags="imp"/>
    </def-attr>
    <def-attr n="a_neg">
      <attr-item tags="neg"/>
    </def-attr>
  </section-def-attrs>

  <section-def-vars>
    <def-var n="number"/>
    <def-var n="negation"/>
    <def-var n="gender"/>
    <def-var n="case"/>
    <def-var n="preposition"/>
    <def-var n="possessive"/>
    <def-var n="animacy"/>
  </section-def-vars>

  <section-def-macros>

    <def-macro n="convert-neg-to-ne.adv" npar="1">
      <!-- arg.1 verb -> v_negation
           Sets the 'negation' variable to '^не<adv>$ ' if the verb contains <neg> tag. -->
      <let><var n="negation"/><lit v=""/></let>
      <choose>
        <when>
          <test>
            <equal><clip pos="1" side="sl" part="a_neg"/><lit-tag v="neg"/></equal>
          </test>
          <let><var n="negation"/><concat><lit v="^не"/><lit-tag v="adv"/><lit v="$ "/></concat></let>
        </when>
      </choose>
    </def-macro>

    <def-macro n="return-number-of-sl-word" npar="1">
      <!-- arg.1 any nominal -> v_number
           Sets the 'number' variable to '<pl>' if the word contains the '<pl>' tag,
           to '<sg>' otherwise (in context of Tatar, singular is the absence of the
           plural affix). -->
      <choose>
        <when>
          <test>
            <equal>
              <clip pos="1" side="sl" part="a_nbr"/>
              <lit-tag v="pl"/>
            </equal>
          </test>
          <let><var n="number"/><lit-tag v="pl"/></let>
        </when>
        <otherwise>
          <let><var n="number"/><lit-tag v="sg"/></let>
        </otherwise>   
      </choose>
    </def-macro>

    <def-macro n="build-poss-determiner-from-poss-affix" npar="1">
      <!-- arg.1 any nominal -> v_possessive
           Sets the value of the 'possessive' variable to a possessive determiner if the nominal
           contains a possessive affix.
           GIVEN:  ^абый<n><px1sg><nom>/брат<n><m><aa><px1sg><nom>$
           EXPECT: possessive = ^мой<det><pos><m><an><sg><nom>$
           GIVEN:  ^абый<n><px1sg><acc>/брат<n><m><aa><px1sg><acc>$
           EXPECT: possessive = ^мой<det><pos><m><aa><sg><acc>$ -->
      <let><var n="possessive"/><lit v=""/></let>
      <choose>
        <when c="If gender is masculin or number is plural, in accusative we want to take the
                 animacy tag of the noun, otherwise it should be set to 'an'.">
          <test>
            <and>
              <equal><clip pos="1" side="tl" part="a_case"/><lit-tag v="acc"/></equal>
              <or>
                <equal><clip pos="1" side="tl" part="a_gender"/><lit-tag v="m"/></equal>
                <equal><clip pos="1" side="tl" part="a_nbr"/><lit-tag v="pl"/></equal>
              </or>
            </and>
          </test>
          <let><var n="animacy"/><clip pos="1" side="tl" part="a_anim"/></let>
        </when>
        <otherwise>
          <let><var n="animacy"/><lit-tag v="an"/></let>
        </otherwise>
      </choose>
      <choose>
        <when>
          <test><and>
            <equal><clip pos="1" side="tl" part="a_nbr"/><lit-tag v="sg"/></equal>
            <equal><clip pos="1" side="sl" part="a_poss"/><lit-tag v="px1sg"/></equal>
          </and></test>
          <let><var n="possessive"/>
          <concat>
            <lit v="^мой"/>
            <lit-tag v="det"/><lit-tag v="pos"/>
            <clip pos="1" side="tl" part="a_gender"/>
            <var n="animacy"/>
            <clip pos="1" side="tl" part="a_nbr"/>
            <clip pos="1" side="tl" part="a_case"/>
            <lit v="$ "/>
          </concat>
          </let>  
        </when>
        <when>
          <test><and>
            <equal><clip pos="1" side="tl" part="a_nbr"/><lit-tag v="pl"/></equal>
            <equal><clip pos="1" side="sl" part="a_poss"/><lit-tag v="px1sg"/></equal>
          </and></test>
          <let><var n="possessive"/>
          <concat>
              <lit v="^мой"/>
              <lit-tag v="det"/><lit-tag v="pos"/>
              <lit-tag v="mfn"/>
              <var n="animacy"/>
              <clip pos="1" side="tl" part="a_nbr"/>
              <clip pos="1" side="tl" part="a_case"/>
              <lit v="$ "/>
          </concat>
          </let>  
        </when>
        <when>
          <test><and>
            <equal><clip pos="1" side="tl" part="a_nbr"/><lit-tag v="sg"/></equal>
            <equal><clip pos="1" side="sl" part="a_poss"/><lit-tag v="px2sg"/></equal>
          </and></test>
          <let><var n="possessive"/>
          <concat>
            <lit v="^твой"/>
            <lit-tag v="det"/><lit-tag v="pos"/>
            <clip pos="1" side="tl" part="a_gender"/>
            <var n="animacy"/>
            <clip pos="1" side="tl" part="a_nbr"/>
            <clip pos="1" side="tl" part="a_case"/>
            <lit v="$ "/>
          </concat>
          </let>  
        </when>
        <when>
          <test><and>
            <equal><clip pos="1" side="tl" part="a_nbr"/><lit-tag v="pl"/></equal>
            <equal><clip pos="1" side="sl" part="a_poss"/><lit-tag v="px2sg"/></equal>
          </and></test>
          <let><var n="possessive"/>
          <concat>
            <lit v="^твой"/>
            <lit-tag v="det"/><lit-tag v="pos"/>
            <lit-tag v="mfn"/>
            <var n="animacy"/>
            <clip pos="1" side="tl" part="a_nbr"/>
            <clip pos="1" side="tl" part="a_case"/>
            <lit v="$ "/>
          </concat>
          </let>  
        </when>
      </choose>
    </def-macro>

    <def-macro n="translate-noun" npar="1">
      <!-- arg.1 noun -> v_preposition v_possessive noun
           Translates ablative, locative, similiative cases with the variable 'preposition'
           and noun, <px><nom> with genitive, other cases remain as they are. If the noun
           has a possessive affix, stores a corresponding possessive determiner in 'possessive'
           variable.
           Modifies variables and TL noun so that they are generatable (or, in case of variables,
           empty). -->
      <call-macro n="return-number-of-sl-word">
        <with-param pos="1"/>
      </call-macro>
      <choose>
        <when>
          <test>
            <or>
              <equal><clip pos="1" side="tl" part="a_case"/><lit-tag v="nom"/></equal>
              <equal><clip pos="1" side="tl" part="a_case"/><lit-tag v="gen"/></equal>
              <equal><clip pos="1" side="tl" part="a_case"/><lit-tag v="dat"/></equal>
              <equal><clip pos="1" side="tl" part="a_case"/><lit-tag v="acc"/></equal>
            </or>
          </test>
          <let><var n="preposition"/><lit v=""/></let>
          <let><var n="case"/><clip pos="1" side="tl" part="a_case"/></let>
        </when>
        <when>
          <test><equal><clip pos="1" side="tl" part="a_case"/><lit-tag v="abl"/></equal></test>
          <let><var n="preposition"/><concat><lit v="^из"/><lit-tag v="pr"/><lit v="$ "/></concat></let>
          <let><var n="case"/><lit-tag v="gen"/></let>
        </when>
        <when>
          <test><equal><clip pos="1" side="tl" part="a_case"/><lit-tag v="loc"/></equal></test>
          <let><var n="preposition"/><concat><lit v="^в"/><lit-tag v="pr"/><lit v="$ "/></concat></let>
          <let><var n="case"/><lit-tag v="prp"/></let>
        </when>
        <when>
          <test><equal><clip pos="1" side="sl" part="a_case"/><lit-tag v="sim"/></equal></test>
          <let><var n="preposition"/><concat><lit v="^как"/><lit-tag v="adv"/><lit-tag v="rel"/><lit v="$ "/></concat></let>
          <let><var n="case"/><lit-tag v="nom"/></let>
        </when>
        <when>
          <test><equal><clip pos="1" side="sl" part="a_px"/><lit-tag v="px"/></equal></test>
          <let><var n="case"/><lit-tag v="gen"/></let>
        </when>
      </choose>
      <choose>
        <when>
          <test>
	    <and>
              <equal><clip pos="1" side="tl" part="a_pos"/><lit-tag v="adj"/></equal>
	      <equal><var n="number"/><lit-tag v="pl"/></equal>
	    </and>
	  </test>
	  <let><clip pos="1" side="tl" part="a_gender"/><lit-tag v="mfn"/></let>
	</when>
      </choose>
      <choose>
        <when>
          <test>
	    <and>
              <equal><clip pos="1" side="tl" part="a_pos"/><lit-tag v="adj"/></equal>
              <equal><clip pos="1" side="tl" part="a_case"/><lit-tag v="acc"/></equal>
	      <or>
		<equal><clip pos="1" side="tl" part="a_gender"/><lit-tag v="m"/></equal>
		<equal><clip pos="1" side="tl" part="a_gender"/><lit-tag v="mfn"/></equal>
	      </or>
	    </and>
	  </test>
	  <let><clip pos="1" side="tl" part="a_anim"/><lit-tag v="aa"/></let>
	</when>
      </choose>
      <choose>
        <when>
          <test>
	    <and>
              <equal><clip pos="1" side="tl" part="a_pos"/><lit-tag v="np.cog"/></equal>
	      <equal><var n="number"/><lit-tag v="pl"/></equal>
	    </and>
	  </test>
	  <let><clip pos="1" side="tl" part="a_gender"/><lit-tag v="mf"/></let>
	</when>
      </choose>
      <let>
        <clip pos="1" side="tl" part="whole"/>
        <concat>
          <clip pos="1" side="tl" part="lemh"/>
          <clip pos="1" side="tl" part="a_nom"/>
          <clip pos="1" side="tl" part="a_gender"/>
          <clip pos="1" side="tl" part="a_anim"/>
          <var n="number"/>
          <var n="case"/>
          <clip pos="1" side="tl" part="lemq"/>
        </concat>
      </let>
      <call-macro n="build-poss-determiner-from-poss-affix">
        <with-param pos="1"/>
      </call-macro>
    </def-macro>
    
    <def-macro n="adapt-det" npar="1">
      <!-- arg.1 determiner (det.pos, det.dem etc) -> determiner
           Sets the determiner to the default <m.an.sg.nom> (to be agreed with the head of the NP in another macro).
           GIVEN: ^бу<det><dem>/этот<det><dem>$ EXPECT: ^бу<det><dem>/^этот<det><dem><m><an><sg><nom>$ -->
      <let>
        <clip pos="1" side="tl" part="whole"/>
        <concat>
          <clip pos="1" side="tl" part="lem"/>
          <clip pos="1" side="tl" part="a_det"/>
          <lit-tag v="m"/>
          <lit-tag v="an"/>
          <lit-tag v="sg"/>
          <lit-tag v="nom"/>
        </concat>
      </let>
    </def-macro>

    <def-macro n="translate-verb-fin" npar="1">
      <!-- arg.1 finiteVerb -> v_negation finiteVerb
           Converts negation, tenses and features related to it (such as gender
           in the past tense). Strips transitivity tag (rus.dix doesn't support it yet).
           GIVEN:  ^уйна<v><tv><pres><p1><sg>/играть<vblex><impf><tv><pres><p1><sg>$
           EXPECT: ^уйна<v><tv><pres><p1><sg>/играть<vblex><impf><pres><p1><sg>$
           GIVEN:  ^уйна<v><tv><neg><ifi><p3><pl>/играть<vblex><impf><tv><neg><ifi><p3><pl>$
           EXPECT: ^уйна<v><tv><neg><ifi><p3><pl>/играть<vblex><impf><past><mfn><pl>$ negation='не<adv>' -->
      <let><var n="gender"/><lit v=""/></let>
      <call-macro n="convert-neg-to-ne.adv">
        <with-param pos="1"/>
      </call-macro>
      <choose>
        <when>
          <test><equal><clip pos="1" side="sl" part="a_tense"/><lit-tag v="ifi"/></equal></test>
          <let><clip pos="1" side="tl" part="a_tense"/><lit-tag v="past"/></let>
        </when>
      </choose>
      <choose>
        <when>
          <test>
            <and>
              <equal><clip pos="1" side="tl" part="a_tense"/><lit-tag v="past"/></equal>
              <equal><clip pos="1" side="tl" part="a_nbr"/><lit-tag v="pl"/></equal>
            </and>
          </test>
          <let><var n="gender"/><lit-tag v="mfn"/></let>
          <let><clip pos="1" side="tl" part="a_pers"/><lit v=""/></let> <!-- no person in past tense in Russian -->
        </when>
        <when>
          <test>
            <and>
              <equal><clip pos="1" side="tl" part="a_tense"/><lit-tag v="past"/></equal>
              <not><equal><clip pos="1" side="tl" part="a_nbr"/><lit-tag v="pl"/></equal></not>
            </and>
          </test>
          <let><var n="gender"/><lit-tag v="m"/></let>
          <let><clip pos="1" side="tl" part="a_pers"/><lit v=""/></let> <!-- no person in past tense in Russian -->
        </when>
      </choose>
      <let>
        <clip pos="1" side="tl" part="whole"/>
        <concat>
            <clip pos="1" side="tl" part="lemh"/>
            <clip pos="1" side="tl" part="a_vblex"/>
            <clip pos="1" side="tl" part="a_tense"/>
            <var n="gender"/>
            <clip pos="1" side="tl" part="a_pers"/>
            <clip pos="1" side="tl" part="a_nbr"/>
            <clip pos="1" side="tl" part="lemq"/>
        </concat>
      </let>
    </def-macro>

    <def-macro n="concord2" npar="2">
      <!-- arg.1 determiner arg.2 noun -> determiner noun
           Concords gender, animacy, number, case of the determiner with the head of the NP.
           Assumes that the head of the NP was already 'translated'. -->

      <!-- "First, copy everything except for animacy from the noun (for some reason some of the
           possessive determiners do not receive animacy tag in rus.dix)."-->
      <let>
        <clip pos="1" side="tl" part="whole"/>
        <concat>
          <clip pos="1" side="tl" part="lem"/>
          <clip pos="1" side="tl" part="a_det"/>
          <clip pos="2" side="tl" part="a_gender"/>
          <clip pos="1" side="tl" part="a_anim"/>
          <clip pos="2" side="tl" part="a_nbr"/>
          <clip pos="2" side="tl" part="a_case"/>
        </concat>
      </let>
      <!-- Now adjust -->
      <choose>
        <when>
          <test><equal><clip pos="1" side="tl" part="a_nbr"/><lit-tag v="pl"/></equal></test>
          <let><clip pos="1" side="tl" part="a_gender"/><lit-tag v="mfn"/></let>
        </when>
      </choose>
      <choose>
        <when c="If the gender is masculin or number is plural, in accusative we want to take the
                 animacy tag of the noun, otherwise it should be set to 'an'.">
          <test>
            <and>
              <or>
                <equal><clip pos="1" side="tl" part="a_gender"/><lit-tag v="m"/></equal>
                <equal><clip pos="1" side="tl" part="a_gender"/><lit-tag v="mfn"/></equal>
              </or>
              <equal><clip pos="1" side="tl" part="a_case"/><lit-tag v="acc"/></equal>
            </and>
          </test>
          <let><clip pos="1" side="tl" part="a_anim"/><clip pos="2" side="tl" part="a_anim"/></let>
        </when>
        <otherwise>
          <let><clip pos="1" side="tl" part="a_anim"/><lit-tag v="an"/></let>
        </otherwise>
      </choose>
    </def-macro>

  </section-def-macros>

  <section-rules>

<!-- SECTION: Noun phrases -->

    <rule comment="REGLA: N">
      <!--
          INPUT:  ^мәктәп<n><attr>/школьный<adj><m><an><sg><nom>$
          OUTPUT: ^adj<AdjP>{^школьный<adj><m><an><sg><nom>$}$
          INPUT:  ^мәктәп<n><nom>/школа<n><f><nn><nom>$
          OUTPUT: ^n<SN>{^школа<n><f><nn><sg><nom>$}$
          INPUT:  ^абый<n><px1sg><dat>/брат<n><m><aa><px1sg><dat>$
          OUTPUT: ^n<SN>{^мой<det><pos><m><an><sg><dat>$ ^брат<n><m><aa><sg><dat>$}$
          INPUT:  ^мәктәп<n><loc>/школа<n><f><nn><loc>$
          OUTPUT: ^pr_n<PP>{^в<pr>$ ^школа<n><f><nn><sg><prp>$}$
	  INPUT:  ^яхшы<adj><subst><dat>/хороший<adj><m><an><dat>$
          OUTPUT: ^n<SN>{^хороший<adj><m><an><sg><dat>$}$
      -->
      <pattern>
        <pattern-item n="n"/>
      </pattern>
      <action>
        <choose>
          <when>
            <test>
	      <and>
	        <equal><clip pos="1" side="sl" part="a_syn"/><lit-tag v="attr"/></equal>
	        <equal><clip pos="1" side="tl" part="a_pos"/><lit-tag v="adj"/></equal>
	      </and>
	    </test>
            <out>
              <chunk name="adj" case="caseFirstWord">
                <tags>
                  <tag><lit-tag v="AdjP"/></tag>
                </tags>
                <lu>
                  <clip pos="1" side="tl" part="whole"/>
                </lu>
              </chunk>
            </out>
          </when>
          <otherwise>
            <call-macro n="translate-noun">
              <with-param pos="1"/>
            </call-macro>
            <choose>
              <when>
                <test><equal><var n="preposition"/><lit v=""/></equal></test>
                <out>
                  <chunk name="n" case="caseFirstWord">
                    <tags>
                      <tag><lit-tag v="SN"/></tag>
                    </tags>
                    <var n="possessive"/>
                    <lu>
                      <clip pos="1" side="tl" part="whole"/>
                    </lu>
                  </chunk>
                </out>
              </when>
              <otherwise>
                <out>
                  <chunk name="pr_n" case="caseFirstWord">
                    <tags>
                      <tag><lit-tag v="PP"/></tag>
                    </tags>
                    <var n="preposition"/>
                    <var n="possessive"/>
                    <lu>
                      <clip pos="1" side="tl" part="whole"/>
                    </lu>
                  </chunk>
                </out>
              </otherwise>
            </choose>
          </otherwise>
        </choose>
      </action>
    </rule>

    <rule comment="REGLA: N N">
      <!--
        INPUT:  ^урындык<n><attr>/стул<n><m><nn><attr>$ ^аст<n><pl><px3sp><acc>/низ<n><m><nn><pl><px3sp><acc>$
        OUTPUT: ^n_n<SN>{^низ<n><m><nn><pl><acc>$ ^стул<n><m><nn><sg><gen>$}$
        INPUT:  ^Өй<n><attr>/Дом<n><m><nn><attr>$ ^алд<n><px3sp><loc>/перед<pr><ins>$
        OUTPUT: ^pr_n<PP>{^Перед<pr>$ ^дом<n><m><nn><sg><ins>$}$
      -->
      <pattern>
        <pattern-item n="n-attr-or-gen"/>
        <pattern-item n="n-px3sp"/>
      </pattern>
      <action>
        <choose>
          <when c="n.px3sp.{dat/abl/loc} is translated with a preposition">
            <test><equal><clip pos="2" side="tl" part="a_pos"/><lit-tag v="pr"/></equal></test>
            <out>
              <chunk name="pr_n" case="caseFirstWord">
                <tags>
                  <tag><lit-tag v="PP"/></tag>
                </tags>
                <lu>
                  <get-case-from pos="1">
                    <clip pos="2" side="tl" part="lem"/>
                  </get-case-from>
                  <clip pos="2" side="tl" part="a_pr"/>
                </lu>
                <b/>
                <lu>
                  <get-case-from pos="2">
                    <clip pos="1" side="tl" part="lem"/>
                  </get-case-from>
                  <clip pos="1" side="tl" part="a_nom"/>
                  <clip pos="1" side="tl" part="a_gender"/>
                  <clip pos="1" side="tl" part="a_anim"/>
                  <lit-tag v="sg"/>
                  <clip pos="2" side="tl" part="a_case"/>
                </lu>
              </chunk>
            </out>
          </when>
          <otherwise>
            <call-macro n="translate-noun">
              <with-param pos="2"/>
            </call-macro>
            <call-macro n="return-number-of-sl-word">
              <with-param pos="1"/>
            </call-macro>
	    <choose>
              <when>
		<test>
		  <and>
		    <equal><clip pos="1" side="tl" part="a_pos"/><lit-tag v="np.cog"/></equal>
		    <equal><var n="number"/><lit-tag v="pl"/></equal>
		  </and>
		</test>
		<let><clip pos="1" side="tl" part="a_gender"/><lit-tag v="mf"/></let>
	      </when>
	    </choose>
            <out>
              <chunk name="n_n">
                <tags>
                  <tag><lit-tag v="SN"/></tag>
                </tags>
                <var n="preposition"/>
                <lu>
                  <clip pos="2" side="tl" part="whole"/>
                </lu>
                <b/>
                <lu>
                  <clip pos="1" side="tl" part="lem"/>
                  <clip pos="1" side="tl" part="a_nom"/>
                  <clip pos="1" side="tl" part="a_gender"/>
                  <clip pos="1" side="tl" part="a_anim"/>
                  <var n="number"/>
                  <lit-tag v="gen"/>
                </lu>
              </chunk>
            </out>
          </otherwise>
        </choose>
      </action>
    </rule>

    <rule comment="REGLA: N POST">
      <!--
        INPUT:  ^мәктәп<n>/школа<n><f><nn>$ ^сыз<post>/без<pr><gen>$
        OUTPUT: ^pr_n<PP>{^без<pr>$ ^школа<n><f><nn><sg><gen>$}$
        INPUT:  ^яхшы<adj><subst><pl>/хороший<adj><m><an><pl>$ ^сыз<post>/без<pr><gen>$
        OUTPUT: ^pr_n<PP>{^без<pr>$ ^хороший<adj><mfn><an><pl><gen>$}$
      -->
      <pattern>
        <pattern-item n="n"/>
        <pattern-item n="post"/>
      </pattern>
      <action>
        <call-macro n="return-number-of-sl-word">
          <with-param pos="1"/>
        </call-macro>
	<choose>
          <when>
            <test>
	      <and>
		<equal><clip pos="1" side="tl" part="a_pos"/><lit-tag v="adj"/></equal>
		<equal><var n="number"/><lit-tag v="pl"/></equal>
	      </and>
	    </test>
	    <let><clip pos="1" side="tl" part="a_gender"/><lit-tag v="mfn"/></let>
	  </when>
	</choose>
        <out>
          <chunk name="pr_n" case="caseFirstWord">
            <tags>
              <tag><lit-tag v="PP"/></tag>
            </tags>
            <lu>
              <clip pos="2" side="tl" part="lem"/>
              <clip pos="2" side="tl" part="a_pr"/>
              </lu>
              <b/>
              <lu>
                <clip pos="1" side="tl" part="lem"/>
                <clip pos="1" side="tl" part="a_nom"/>
                <clip pos="1" side="tl" part="a_gender"/>
                <clip pos="1" side="tl" part="a_anim"/>
                <var n="number"/>
                <clip pos="2" side="tl" part="a_case"/>
              </lu>
            </chunk>
          </out>
      </action>
    </rule>

    <rule comment="REGLA: N POST N">
      <!--
        INPUT:  ^өй<n><attr>/дом<n><m><nn><attr>$ ^алд<n><px3sp><loc><attr>/перед<pr><ins><attr>$ ^бакча<n><loc>/сад<n><m><nn><loc>$
        OUTPUT: ^n_pr_n<SN>{^в<pr>$ ^сад<n><m><nn><sg><prp>$ ^перед<pr>$ ^дом<n><m><nn><sg><ins>$}$
      -->
      <pattern>
        <pattern-item n="n-attr-or-gen"/>
        <pattern-item n="npost-attr"/>
        <pattern-item n="n"/>
      </pattern>
      <action>
        <call-macro n="translate-noun">
          <with-param pos="3"/>
        </call-macro>
        <out>
          <chunk name="n_pr_n" case="caseFirstWord">
            <tags>
              <tag><lit-tag v="SN"/></tag>
            </tags>
            <var n="preposition"/>
            <lu>
              <clip pos="3" side="tl" part="whole"/>
            </lu>
            <b/>
            <lu>
              <clip pos="2" side="tl" part="lem"/>
              <clip pos="2" side="tl" part="a_pr"/>
            </lu>
            <b/>
            <lu>
              <clip pos="1" side="tl" part="lem"/>
              <clip pos="1" side="tl" part="a_nom"/>
              <clip pos="1" side="tl" part="a_gender"/>
              <clip pos="1" side="tl" part="a_anim"/>
              <lit-tag v="sg"/>
              <clip pos="2" side="tl" part="a_case"/>
            </lu>
          </chunk>
        </out>
      </action>
    </rule>

    <rule comment="REGLA: NUM N">
      <!--
          INPUT:  ^биш<num>/пять<num><mfn><pl><CD>$ ^яшь<n><nom>/год<n><m><nn><nom>$
          OUTPUT: ^num_n<SN>{^пять<num><mfn><pl><nom>$ ^год<n><m><nn><pl><gen>$}$
          INPUT:  ^биш<num>/пять<num><mfn><pl><CD>$ ^яшь<n><dat>/год<n><m><nn><dat>$
          OUTPUT: ^num_n<SN>{^пять<num><mfn><pl><dat>$ ^год<n><m><nn><pl><dat>$}$
      -->
      <pattern>
        <pattern-item n="num"/>
        <pattern-item n="n"/>
      </pattern>
      <action>
        <call-macro n="translate-noun">
          <with-param pos="2"/>
        </call-macro>
        <!-- Adjust noun's number to numeral's number -->
        <let><clip pos="2" side="tl" part="a_nbr"/><clip pos="1" side="tl" part="a_nbr"/></let>
        <!-- Adjust numeral's case to noun's case -->
        <let><clip pos="1" side="tl" part="a_case"/><clip pos="2" side="tl" part="a_case"/></let>
        <choose>
          <when c="If the noun's case is nominative, change it to genitive
                   (except when the numeral is 'один')">
            <test>
              <and>
                <not><equal caseless="yes"><clip pos="1" side="tl" part="lem"/><lit v="один"/></equal></not>
                <equal><clip pos="2" side="tl" part="a_case"/><lit-tag v="nom"/></equal>
              </and>
            </test>
            <let><clip pos="2" side="tl" part="a_case"/><lit-tag v="gen"/></let>
          </when>
        </choose>
        <out>
          <chunk name="num_n">
            <tags>
              <tag><lit-tag v="SN"/></tag>
            </tags>
            <var n="preposition"/>
            <lu>
              <clip pos="1" side="tl" part="whole"/>
            </lu>
            <b/>
            <lu>
              <clip pos="2" side="tl" part="whole"/>
            </lu>
          </chunk>
        </out>
      </action>
    </rule>

    <rule comment="PRN N">
      <!--
          INPUT:  ^мин<prn><pers><p1><sg><gen>/мой<det><pos><m><an>$ ^бакча<n><px1sg><nom>/сад<n><m><nn><px1sg><nom>$
          OUTPUT: ^det_n<SN>{^мой<det><pos><m><an><sg><nom>$ ^сад<n><m><nn><sg><nom>$}$
      -->
      <pattern>
        <pattern-item n="prn-gen"/>
        <pattern-item n="n-px"/>
      </pattern>
      <action>
        <choose>
          <when c="n.px3sp.{dat/abl/loc} is translated with a preposition">
            <test><equal><clip pos="2" side="tl" part="a_pos"/><lit-tag v="pr"/></equal></test>
            <out>
              <chunk name="pr">
                <tags>
                  <tag><lit-tag v="PREP"/></tag>
                </tags>
                <lu>
                  <clip pos="2" side="tl" part="lem"/>
                  <clip pos="2" side="tl" part="a_pr"/>
                </lu>
              </chunk>
              <b/>
              <chunk name="n">
                <tags>
                  <tag><lit-tag v="SN"/></tag>
                </tags>
                <lu>
                  <clip pos="1" side="tl" part="whole"/>
                </lu>
              </chunk>
            </out>
          </when>
          <otherwise>
            <call-macro n="translate-noun">
              <with-param pos="2"/>
            </call-macro>
            <call-macro n="concord2">
              <with-param pos="1"/>
              <with-param pos="2"/>
            </call-macro>
            <choose>
              <when c="'его' and 'их' do not take animacy or gender tags">
                <test>
                  <or>
                    <equal caseless="yes"><clip pos="1" side="tl" part="lem"/><lit v="его"/></equal>
                    <equal caseless="yes"><clip pos="1" side="tl" part="lem"/><lit v="их"/></equal>
                  </or>
                </test>
                <out>
                  <chunk name="det_n">
                    <tags>
                      <tag><lit-tag v="SN"/></tag>
                    </tags>
                    <var n="preposition"/>
                    <lu>
                      <clip pos="1" side="tl" part="lem"/>
                      <clip pos="1" side="tl" part="a_det"/>
                    </lu>
                    <b/>
                    <lu>
                      <clip pos="2" side="tl" part="whole"/>
                    </lu>
                  </chunk>
                </out>
              </when>
              <otherwise c="all other possessive determiners">
                <out>
                  <chunk name="det_n">
                    <tags>
                      <tag><lit-tag v="SN"/></tag>
                    </tags>
                    <var n="preposition"/>
                    <lu>
                      <clip pos="1" side="tl" part="whole"/>
                    </lu>
                    <b/>
                    <lu>
                      <clip pos="2" side="tl" part="whole"/>
                    </lu>
                  </chunk>
                </out>
              </otherwise>
            </choose>
          </otherwise>
        </choose>
      </action>
    </rule>

<!-- SECTION: Verb phrases -->

<!--
INPUT:  ^и<cop><p3><sg>/быть<vbser><p3><sg>$
OUTPUT: ^cop-pres<VBSER>{^быть<vbser><pres><p3><sg>$}$
-->
    <rule comment="">
      <pattern>
        <pattern-item n="cop-pres"/>
      </pattern>
      <action>
        <call-macro n="convert-neg-to-ne.adv">
          <with-param pos="1"/>
        </call-macro>
        <out>
          <chunk name="cop-pres">
            <tags>
              <tag><lit-tag v="VBSER"/></tag>
            </tags>
            <var n="negation"/>
            <lu>
              <clip pos="1" side="tl" part="lem"/>
              <clip pos="1" side="tl" part="a_vbser"/>
              <lit-tag v="pres"/>
              <clip pos="1" side="tl" part="a_pers"/>
              <clip pos="1" side="tl" part="a_nbr"/>
            </lu>
          </chunk>
        </out>
      </action>
    </rule>

<!--
INPUT:  ^и<cop><ifi><p3><sg>/быть<vbser><ifi><p3><sg>$
OUTPUT: ^cop<VBSER>{^быть<vbser><past><nt><sg>$}$
-->
    <rule comment="">
      <pattern>
        <pattern-item n="cop-ifi"/>
      </pattern>
      <action>
        <out>
          <chunk name="cop">
            <tags>
              <tag><lit-tag v="VBSER"/></tag>
            </tags>
            <lu>
              <clip pos="1" side="tl" part="lem"/>
              <clip pos="1" side="tl" part="a_vbser"/>
              <lit-tag v="past"/>
              <lit-tag v="nt"/>
              <clip pos="1" side="tl" part="a_nbr"/>
            </lu>
          </chunk>
        </out>
      </action>
    </rule>

<!--
INPUT:  ^уйна<v><tv><pres><p1><sg>/играть<vblex><impf><tv><pres><p1><sg>$
OUTPUT: ^verb<VBLEX>{^играть<vblex><impf><pres><p1><sg>$}$
INPUT:  ^уйна<v><tv><neg><ifi><p3><pl>/играть<vblex><impf><tv><neg><ifi><p3><pl>$
OUTPUT: ^verb<VBLEX>{^не<adv>$ ^играть<vblex><impf><past><mfn><pl>$}$
-->
    <rule comment="">
      <pattern>
        <pattern-item n="verb-fin"/>
      </pattern>
      <action>
        <call-macro n="translate-verb-fin">
          <with-param pos="1"/>
        </call-macro>
        <out>
          <chunk name="verb">
            <tags>
              <tag><lit-tag v="VBLEX"/></tag>
            </tags>
            <var n="negation"/>
            <lu>
              <clip pos="1" side="tl" part="whole"/>
            </lu>
          </chunk>
        </out>
      </action>
    </rule>

<!--
INPUT:  ^уйна<v><tv><ger_past><px3sp><acc>/игра<n><f><nn><px3sp><acc>$
OUTPUT: ^n<SN>{^игра<n><f><nn><sg><acc>$}$
INPUT:  ^и<cop><ger_past><px3sp><acc>/быть<vbser><ger_past><px3sp><acc>$
OUTPUT: ^inf<VBLEX>{^быть<vbser><inf>$}$
INPUT:  ^тап<v><tv><prc_impf>/найти<vblex><perf><tv><prc_impf>$
OUTPUT: ^inf<VBLEX>{^найти<vblex><perf><inf>$}$
-->
    <rule comment="To translate every non-finite form with infinitive is not good,
                   but this is a temporal solution until things get sorted out.">
      <pattern>
        <pattern-item n="verb-nonfin"/>
      </pattern>
      <action>
        <choose>
          <when>
            <test><equal><clip pos="1" side="tl" part="a_nom"/><lit-tag v="n"/></equal></test>
            <call-macro n="translate-noun">
              <with-param pos="1"/>
            </call-macro>
            <out>
              <chunk name="n">
                <tags>
                  <tag><lit-tag v="SN"/></tag>
                </tags>
                <lu>
                  <clip pos="1" side="tl" part="whole"/>
                </lu>
              </chunk>
            </out>
          </when>
          <otherwise>
            <call-macro n="convert-neg-to-ne.adv">
              <with-param pos="1"/>
            </call-macro>
            <out>
              <chunk name="inf">
                <tags>
                  <tag><lit-tag v="VBLEX"/></tag>
                </tags>
                <var n="negation"/>
                <lu>
                  <clip pos="1" side="tl" part="lemh"/>
                  <clip pos="1" side="tl" part="a_vblex"/><!-- OR --><clip pos="1" side="tl" part="a_vbser"/>
                  <lit-tag v="inf"/>
                  <clip pos="1" side="tl" part="lemq"/>
                </lu>
              </chunk>
            </out>
          </otherwise>
        </choose>
      </action>
    </rule>

<!-- SECTION: Modifiers -->

<!--
INPUT:  ^яхшы<adj>/хороший<adj>$
OUTPUT: ^adj<AdjP>{^хороший<adj><m><an><sg><nom>$}$
-->
    <rule comment="">
      <pattern>
        <pattern-item n="adj"/>
      </pattern>
      <action>
        <choose>
          <when>
            <test><equal><clip pos="1" side="tl" part="a_adv"/><lit-tag v="adv"/></equal></test>
            <out>
              <chunk name="adv">
                <tags>
                  <tag><lit-tag v="AdvP"/></tag>
                </tags>
                <lu>
                  <clip pos="1" side="tl" part="whole"/>
                </lu>
              </chunk>
            </out>
          </when>
          <when>
            <test><equal caseless="yes"><clip pos="1" side="tl" part="lem"/><lit v="быть"/></equal></test>
            <out>
              <chunk name="bar">
                <tags>
                  <tag><lit-tag v="VBSER"/></tag>
                </tags>
                <lu>
                  <clip pos="1" side="tl" part="whole"/>
                </lu>
              </chunk>
            </out>
          </when>
          <when>
            <test><equal><clip pos="1" side="tl" part="a_pos"/><lit-tag v="pred"/></equal></test>
            <out>
              <chunk name="pred">
                <tags>
                  <tag><lit-tag v="PRED"/></tag>
                </tags>
                <lu>
                  <clip pos="1" side="tl" part="lem"/>
                  <lit-tag v="pred"/>
                  <lit-tag v="m"/>
                  <lit-tag v="sg"/>
                </lu>
              </chunk>
            </out>
          </when>
          <otherwise>
            <out>
              <chunk name="adj">
                <tags>
                  <tag><lit-tag v="AdjP"/></tag>
                </tags>
                <lu>
                  <clip pos="1" side="tl" part="lem"/>
                  <clip pos="1" side="tl" part="a_adj"/>
                  <lit-tag v="m"/>
                  <lit-tag v="an"/>
                  <lit-tag v="sg"/>
                  <lit-tag v="nom"/>
                </lu>
              </chunk>
            </out>
          </otherwise>
        </choose>
      </action>
    </rule>

    <rule comment="REGLA: DET">
      <!--
        INPUT: ^бер<det><ind>/один<num><num><m><an><sg><CD>$
        OUTPUT: ^det<DET>{^один<num><m><an><sg><nom>$}$
        INPUT: ^бер<num>/один<num><m><an><sg><CD>$
        OUTPUT: ^num<DET>{^один<num><m><an><sg><nom>$}$
      -->
      <pattern>
        <pattern-item n="det"/>
      </pattern>
      <action>
        <call-macro n="adapt-det">
          <with-param pos="1"/>
        </call-macro>
        <out>
          <chunk name="det">
            <tags>
              <tag><lit-tag v="DET"/></tag>
            </tags>
            <lu>
              <clip pos="1" side="tl" part="whole"/>
            </lu>
          </chunk>
        </out>
      </action>
    </rule>

    <rule comment="REGLA: NUM">
      <!--
        INPUT:  ^бер<num>/один<num><m><an><sg><CD>$
        OUTPUT: ^num<DET>{^один<num><m><an><sg><nom>$}$
        INPUT:  ^бер<det><ind>/один<num><num><m><an><sg><CD>$
        OUTPUT: ^det<DET>{^один<num><m><an><sg><nom>$}$
      -->
      <pattern>
        <pattern-item n="num"/>
      </pattern>
      <action>
        <let><clip pos="1" side="tl" part="a_case"/><lit-tag v="nom"/></let>
        <out>
          <chunk name="num">
            <tags>
              <tag><lit-tag v="DET"/></tag>
            </tags>
            <lu>
              <clip pos="1" side="tl" part="lem"/>
              <clip pos="1" side="tl" part="a_num"/>
              <clip pos="1" side="tl" part="a_gender"/>
              <clip pos="1" side="tl" part="a_anim"/>
              <clip pos="1" side="tl" part="a_nbr"/>
              <clip pos="1" side="tl" part="a_case"/>
            </lu>
          </chunk>
        </out>
      </action>
    </rule>

    <rule comment="REGLA: POST">
      <!--
        INPUT:  ^белән<post>/с<pr><ins>$
        OUTPUT: ^pr<PREP>{^с<pr>$}$
        INPUT:  ^бергә<post>/вместе<adv>$
        OUTPUT: ^pr<PREP>{^вместе<adv>$}$
      -->
      <pattern>
        <pattern-item n="post"/>
      </pattern>
      <action>
        <choose>
          <when>
            <test><equal><clip pos="1" side="tl" part="a_pos"/><lit-tag v="pr"/></equal></test>
            <out>
              <chunk name="pr">
                <tags>
                  <tag><lit-tag v="PREP"/></tag>
                </tags>
                <lu>
                  <clip pos="1" side="tl" part="lem"/>
                  <clip pos="1" side="tl" part="a_pr"/>
                </lu>
              </chunk>
            </out>
          </when>
          <otherwise>
            <out>
              <chunk name="pr">
                <tags>
                  <tag><lit-tag v="PREP"/></tag>
                </tags>
                <lu>
                  <clip pos="1" side="tl" part="whole"/>
                </lu>
              </chunk>
            </out>
          </otherwise>
        </choose>
      </action>
    </rule>

    <rule comment="REGLA: SENT">
      <!--
        INPUT:  ^.<sent>/.<sent>$
        OUTPUT: ^dot<SENT>{^.<sent>$}$
      -->
      <pattern>
        <pattern-item n="sent"/>
      </pattern>
      <action>
        <out>
          <chunk name="dot">
            <tags>
              <tag><lit-tag v="SENT"/></tag>
            </tags>
            <lu>
              <clip pos="1" side="tl" part="whole"/>
            </lu>
          </chunk>
        </out>
      </action>
    </rule>

<!-- TODO: Consider handling issues below in the following transfer modules -->

<!--
        (^бел<v><tv><pres><p2><pl>/знать<vblex><impf><tv><pres><p2><pl>$)
INPUT:  ^мы<qst>/@мы<qst>$^?<sent>/?<sent>$
OUTPUT: ^qst<SENT>{^?<sent>$}$
-->
    <rule comment="">
      <pattern>
        <pattern-item n="qst"/>
        <pattern-item n="sent"/>
      </pattern>
      <action>
        <out>
          <chunk name="qst">
            <tags>
              <tag><lit-tag v="SENT"/></tag>
            </tags>
            <lu>
              <clip pos="2" side="tl" part="whole"/>
            </lu>
          </chunk>
        </out>
      </action>
    </rule>

    <rule comment="">
      <!--
        INPUT:  ^Гөлнара<np><ant><f><gen>/Гульнара<np><ant><f><sg><gen>$ ^эт<n><px3sp><nom>/собака<n><f><aa><px3sp><nom>$ ^юк<adj>/быть<vbser><neg><pres><p3><sg>$ ^и<cop><p3><sg>/быть<vbser><p3><sg>$
        Гөлнараның эте юк
        OUTPUT: ^bar-yuq<S>{^у<pr>$ ^Гульнара<np><ant><f><sg><gen>$ ^быть<vbser><neg><pres><p3><sg>$ ^собака<n><f><aa><sg><gen>$}$
        У Гульнары нет собаки
      -->
      <pattern>
        <pattern-item n="n-gen"/>
        <pattern-item n="n-px3sp-nom"/>
        <pattern-item n="yuq-adj"/>
        <pattern-item n="cop-p3"/>
      </pattern>
      <action>
        <call-macro n="return-number-of-sl-word">
          <with-param pos="1"/>
        </call-macro>
        <out>
          <chunk name="bar-yuq">
            <tags>
              <tag><lit-tag v="S"/></tag>
            </tags>
            <lu>
              <lit v="у"/>
              <lit-tag v="pr"/>
            </lu>
            <b/>
            <lu>
              <clip pos="1" side="tl" part="lem"/>
              <clip pos="1" side="tl" part="a_nom"/>
              <clip pos="1" side="tl" part="a_gender"/>
              <clip pos="1" side="tl" part="a_anim"/>
              <var n="number"/>
              <lit-tag v="gen"/>
            </lu>
            <b/>
            <lu>
              <clip pos="3" side="tl" part="whole"/>
            </lu>
            <b/>
            <lu>
              <clip pos="2" side="tl" part="lem"/>
              <clip pos="2" side="tl" part="a_nom"/>
              <clip pos="2" side="tl" part="a_gender"/>
              <clip pos="2" side="tl" part="a_anim"/>
              <lit-tag v="sg"/>
              <lit-tag v="gen"/>
            </lu>
          </chunk>
        </out>
      </action>
    </rule>

  </section-rules>

</transfer>
