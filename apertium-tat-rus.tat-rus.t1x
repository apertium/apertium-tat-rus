<?xml version="1.0" encoding="UTF-8"?>
<!-- -*- nxml -*- -->

<transfer default="chunk">

  <section-def-cats>

    <def-cat n="noun">
      <cat-item tags="n.nom"/>
      <cat-item tags="n.pl.nom"/>
      <cat-item tags="n.gen"/>
      <cat-item tags="n.pl.gen"/>
      <cat-item tags="n.dat"/>
      <cat-item tags="n.pl.dat"/>
      <cat-item tags="n.acc"/>
      <cat-item tags="n.pl.acc"/>
      <cat-item tags="n.abl"/>
      <cat-item tags="n.pl.abl"/>
      <cat-item tags="n.loc"/>
      <cat-item tags="n.pl.loc"/>
      <cat-item tags="n.px.nom"/>
      <cat-item tags="n.pl.px.nom"/>
      <cat-item tags="prn.pers.*.*.*."/>
      <cat-item tags="prn.dem.*"/>
      <cat-item tags="prn.itg.*"/>
      <cat-item tags="prn.neg.*"/>
      <cat-item tags="np.ant.*"/>
    </def-cat>
    <def-cat n="noun-gen">
      <cat-item tags="n.gen"/>
      <cat-item tags="np.ant.f.gen"/>
    </def-cat>
    <def-cat n="noun-loc">
      <cat-item tags="n.loc"/>
      <cat-item tags="n.pl.loc"/>
    </def-cat>
    <def-cat n="noun-px3sp-nom">
      <cat-item tags="n.px3sp.nom"/>
    </def-cat>
    <def-cat n="noun-px3sp">
      <cat-item tags="n.px3sp.*"/>
      <cat-item tags="n.pl.px3sp.*"/>
    </def-cat>
    <def-cat n="noun-px">
      <cat-item tags="n.px1sg.*"/>
      <cat-item tags="n.*.px1sg.*"/>
      <cat-item tags="n.px2sg.*"/>
      <cat-item tags="n.*.px2sg.*"/>
      <cat-item tags="n.px3sp.*"/>
      <cat-item tags="n.*.px3sp.*"/>
      <cat-item tags="n.px1pl.*"/>
      <cat-item tags="n.*.px1pl.*"/>
      <cat-item tags="n.px2pl.*"/>
      <cat-item tags="n.*.px2pl.*"/>
    </def-cat>
    <def-cat n="noun-attr">
      <cat-item tags="n.attr"/>
    </def-cat>
    <def-cat n="nounpost">
      <cat-item lemma="алд" tags="n.px3sp.loc"/>
      <cat-item lemma="арт" tags="n.px3sp.loc"/>
      <cat-item lemma="ян" tags="n.px3sp.loc"/>
    </def-cat>
    <def-cat n="nounpost-attr">
      <cat-item lemma="алд" tags="n.px3sp.loc.attr"/>
    </def-cat>

    <def-cat n="prn-gen">
      <cat-item tags="prn.pers.*.*.gen"/>
      <cat-item lemma="ул" tags="prn.dem.gen"/>
      <cat-item lemma="ул" tags="prn.dem.pl.gen"/> 
   </def-cat>

    <def-cat n="adj">
      <cat-item tags="adj"/>
    </def-cat>
    <def-cat n="yuq-adj">
      <cat-item lemma="юк" tags="adj"/>
    </def-cat>

    <def-cat n="det">
      <cat-item tags="det.*"/>
    </def-cat>

    <def-cat n="num">
      <cat-item tags="num"/>
      <cat-item tags="num.*"/>
    </def-cat>

    <def-cat n="cop-p3">
      <cat-item tags="cop.p3.sg"/>
      <cat-item tags="cop.p3.pl"/>
    </def-cat>
    <def-cat n="cop-pres">
      <cat-item tags="cop.p1.*"/>
      <cat-item tags="cop.p2.*"/>
      <cat-item tags="cop.p3.*"/>
      <cat-item tags="cop.neg.p3.*"/>
    </def-cat>
    <def-cat n="cop-ifi">
      <cat-item tags="cop.ifi.*.*"/>
    </def-cat>

    <def-cat n="verb-fin">
      <cat-item tags="v.*.pres.*"/>
      <cat-item tags="v.*.*.pres.*"/>
      <cat-item tags="vaux.pres.*"/>
      <cat-item tags="vaux.neg.pres.*"/>
      <cat-item tags="v.*.ifi.*"/>
      <cat-item tags="v.*.*.ifi.*"/>
      <cat-item tags="vaux.ifi.*"/>
      <cat-item tags="vaux.neg.ifi.*"/>
      <cat-item tags="v.*.past.*"/>
      <cat-item tags="v.*.*.past.*"/>
      <cat-item tags="vaux.past.*"/>
      <cat-item tags="vaux.neg.past.*"/>
      <cat-item tags="v.*.imp.*"/>
      <cat-item tags="v.*.*.imp.*"/>
    </def-cat>
    <def-cat n="verb-nonfin">
      <cat-item tags="v.*.inf"/>
      <cat-item tags="v.*.*.inf.*"/>
      <cat-item tags="v.*.prc_perf"/>
      <cat-item tags="v.*.*.prc_perf"/>
      <cat-item tags="v.*.prc_impf"/>
      <cat-item tags="v.*.*.prc_impf"/>
      <cat-item tags="v.*.gna_perf"/>
      <cat-item tags="v.*.*.gna_perf"/>
      <cat-item tags="v.*.gna_impf"/>
      <cat-item tags="v.*.*.gna_impf"/>
      <cat-item tags="v.*.prc_fut"/>
      <cat-item tags="v.*.*.prc_fut"/>
      <cat-item tags="v.*.prc_fut"/>
      <cat-item tags="v.*.*.prc_fut"/>
      <cat-item tags="v.*.prc_vol_"/>
      <cat-item tags="v.*.ger_past.*"/>
      <cat-item tags="v.*.*.ger_past.*"/>
      <cat-item tags="cop.ger_past.*"/>
      <cat-item tags="cop.*.ger_past.*"/>
      <cat-item tags="v.*.gpr_past"/>
      <cat-item tags="v.*.*.gpr_past"/>
      <cat-item tags="v.*.gpr_past.*"/>
      <cat-item tags="v.*.*.gpr_past.*"/>
      <cat-item tags="v.*.gpr_fut.*"/>
      <cat-item tags="v.*.*.gpr_fut.*"/>
      <cat-item tags="v.*.gpr_fut"/>
      <cat-item tags="v.*.*.gpr_fut"/>
      <cat-item tags="v.*.gpr_fut3"/>
      <cat-item tags="v.*.*.gpr_fut3"/>
      <cat-item tags="v.*.gna_after"/>
      <cat-item tags="v.*.*.gna_after"/>
      <cat-item tags="vaux.gna_after"/>
      <cat-item tags="vaux.*.gna_after"/>
      <cat-item tags="v.*.gna_cond.*"/>
      <cat-item tags="v.*.*.gna_cond.*"/>
    </def-cat>

    <def-cat n="qst">
      <cat-item tags="qst"/>
    </def-cat>
    <def-cat n="sent">
      <cat-item tags="sent"/>
    </def-cat>
    <def-cat n="cm">
      <cat-item tags="cm"/>
    </def-cat>

  </section-def-cats>

  <section-def-attrs>
    <def-attr n="a_pos">
      <attr-item tags="n"/>
      <attr-item tags="np"/>
      <attr-item tags="pred"/>
      <attr-item tags="pr"/>
    </def-attr>
    <def-attr n="a_noun">
      <attr-item tags="n"/>
      <attr-item tags="np.ant"/>
      <attr-item tags="prn.pers.p1"/>
      <attr-item tags="prn.pers.p2"/>
      <attr-item tags="prn.pers.p3"/>
      <attr-item tags="prn.dem"/>
      <attr-item tags="prn.itg"/>
      <attr-item tags="prn.neg"/>
    </def-attr>
    <def-attr n="a_det">
      <attr-item tags="det.dem"/>
      <attr-item tags="det.pos"/>
      <attr-item tags="det.itg"/>
      <attr-item tags="det.ind"/>
      <attr-item tags="num"/>
    </def-attr>
    <def-attr n="a_num">
      <attr-item tags="num"/>
    </def-attr>

    <def-attr n="a_adj">
      <attr-item tags="adj"/>
      <attr-item tags="adj.sint"/>
    </def-attr>
    <def-attr n="a_digit">
      <attr-item tags="digit"/>
    </def-attr>
    <def-attr n="a_adv">
      <attr-item tags="adv"/>
    </def-attr>
    <def-attr n="a_pr">
      <attr-item tags="pr"/>
    </def-attr>
    <def-attr n="a_vbser">
      <attr-item tags="vbser"/>
    </def-attr>
    <def-attr n="a_vblex">
      <attr-item tags="vblex.impf"/>
      <attr-item tags="vblex.perf"/>
      <attr-item tags="vbmod.impf.tv"/> <!-- Modal verbs already receive transitivity tags in rus.dix-->
      <attr-item tags="vbmod.impf.iv"/>
      <attr-item tags="vbmod.perf.tv"/>
      <attr-item tags="vbmod.perf.iv"/>
    </def-attr>
    <def-attr n="a_gender">
      <attr-item tags="m"/>
      <attr-item tags="f"/>
      <attr-item tags="nt"/>
      <attr-item tags="mf"/>
      <attr-item tags="mfn"/>
    </def-attr>
    <def-attr n="a_anim">
      <attr-item tags="aa"/>
      <attr-item tags="nn"/>
      <attr-item tags="an"/>
    </def-attr>
    <def-attr n="a_case">
      <attr-item tags="nom"/>
      <attr-item tags="gen"/>
      <attr-item tags="dat"/>
      <attr-item tags="acc"/>
      <attr-item tags="abl"/>
      <attr-item tags="loc"/>
      <attr-item tags="prp"/>
    </def-attr>
    <def-attr n="a_px">
      <attr-item tags="px"/>
    </def-attr>
    <def-attr n="a_nbr">
      <attr-item tags="sg"/>
      <attr-item tags="pl"/>
    </def-attr>
    <def-attr n="a_pers">
      <attr-item tags="p1"/>
      <attr-item tags="p2"/>
      <attr-item tags="p3"/>
    </def-attr>
    <def-attr n="a_tense">
      <attr-item tags="pres"/>
      <attr-item tags="ifi"/>
      <attr-item tags="past"/>
      <attr-item tags="imp"/>
    </def-attr>
    <def-attr n="a_neg">
      <attr-item tags="neg"/>
    </def-attr>
  </section-def-attrs>

  <section-def-vars>
    <def-var n="number"/>
    <def-var n="negation"/>
    <def-var n="gender"/>
    <def-var n="case"/>
    <def-var n="preposition"/>
  </section-def-vars>

  <section-def-macros>

    <def-macro n="return-number-of-sl-noun" npar="1">
      <!-- arg.1 any nominal -> v_number
           Sets the 'number' variable to '<pl>' if the word contains the '<pl>' tag,
           to '<sg>' otherwise (in context of Tatar, singular is the absence of the
           plural affix). -->
      <choose>
        <when>
          <test>
            <equal>
              <clip pos="1" side="sl" part="a_nbr"/>
              <lit-tag v="pl"/>
            </equal>
          </test>
          <let><var n="number"/><lit-tag v="pl"/></let>
        </when>
        <otherwise>
          <let><var n="number"/><lit-tag v="sg"/></let>
        </otherwise>   
      </choose>
    </def-macro>

    <def-macro n="convert-neg-to-ne.adv" npar="1">
      <!-- arg.1 verb -> v_negation
           Sets the 'negation' variable to '^не<adv>$' if the verb contains <neg> tag. -->
      <let><var n="negation"/><lit v=""/></let>
      <choose>
        <when>
          <test>
            <equal><clip pos="1" side="sl" part="a_neg"/><lit-tag v="neg"/></equal>
          </test>
          <let><var n="negation"/><concat><lit v="^не"/><lit-tag v="adv"/><lit v="$"/></concat></let>
        </when>
      </choose>
    </def-macro>

    <def-macro n="return-case-pr-governs" npar="1">
      <!-- arg.1 prepostion -> v_case
           Sets the 'case' variable to the case which the preposition governs. -->
      <choose>
        <when>
          <test><equal caseless="yes"><clip pos="1" side="tl" part="lem"/><lit v="перед"/></equal></test>
          <let><var n="case"/><lit-tag v="ins"/></let>
        </when>
        <when>
          <test><equal caseless="yes"><clip pos="1" side="tl" part="lem"/><lit v="за"/></equal></test>
          <let><var n="case"/><lit-tag v="ins"/></let>
        </when>
      </choose>
    </def-macro>

    <def-macro n="translate-noun" npar="1">
      <!-- arg.1 noun -> v_preposition noun
           Translates ablative and locative cases with the variable 'preposition' and noun,
           <px><nom> with genitive, other cases remain as they are. -->
      <call-macro n="return-number-of-sl-noun">
        <with-param pos="1"/>
      </call-macro>
      <choose>
        <when>
          <test>
            <or>
              <equal><clip pos="1" side="tl" part="a_case"/><lit-tag v="nom"/></equal>
              <equal><clip pos="1" side="tl" part="a_case"/><lit-tag v="gen"/></equal>
              <equal><clip pos="1" side="tl" part="a_case"/><lit-tag v="dat"/></equal>
              <equal><clip pos="1" side="tl" part="a_case"/><lit-tag v="acc"/></equal>
            </or>
          </test>
          <let><var n="case"/><clip pos="1" side="tl" part="a_case"/></let>
          <let><var n="preposition"/><lit v=""/></let>
        </when>
        <when>
          <test><equal><clip pos="1" side="tl" part="a_case"/><lit-tag v="abl"/></equal></test>
          <let><var n="preposition"/><concat><lit v="^из"/><lit-tag v="pr"/><lit v="$ "/></concat></let>
          <let><var n="case"/><lit-tag v="gen"/></let>
          <choose>
            <when>
              <test><not><equal><clip pos="1" side="tl" part="a_pos"/><lit-tag v="np"/></equal></not></test>
              <modify-case><clip pos="1" side="tl" part="lemh"/><lit v="aa"/></modify-case>
            </when>
          </choose>
        </when>
        <when>
          <test><equal><clip pos="1" side="tl" part="a_case"/><lit-tag v="loc"/></equal></test>
          <let><var n="preposition"/><concat><lit v="^в"/><lit-tag v="pr"/><lit v="$ "/></concat></let>
          <let><var n="case"/><lit-tag v="prp"/></let>
          <choose>
            <when>
              <test><not><equal><clip pos="1" side="tl" part="a_pos"/><lit-tag v="np"/></equal></not></test>
              <modify-case><clip pos="1" side="tl" part="lemh"/><lit v="aa"/></modify-case>
            </when>
          </choose>
        </when>
      </choose>
      <choose>
        <when>
          <test><equal><clip pos="1" side="sl" part="a_px"/><lit-tag v="px"/></equal></test>
          <let><var n="case"/><lit-tag v="gen"/></let>
        </when>
      </choose>
      <let>
        <clip pos="1" side="tl" part="whole"/>
        <concat>
          <clip pos="1" side="tl" part="lemh"/>
          <clip pos="1" side="tl" part="a_noun"/>
          <clip pos="1" side="tl" part="a_gender"/>
          <clip pos="1" side="tl" part="a_anim"/>
          <var n="number"/>
          <var n="case"/>
          <clip pos="1" side="tl" part="lemq"/>
        </concat>
      </let>
    </def-macro>

    <def-macro n="adapt-det" npar="1">
      <!-- arg.1 determiner (det.pos, det.dem etc) -> determiner
           Set the determiner to the default <m.an.sg.nom> (to be agreed with the head of the NP in another macro).
           INPUT: ^бу<det><dem>/этот<det><dem>$ "OUTPUT": ^бу<det><dem>/^этот<det><dem><m><an><sg><nom>$ -->
      <let>
        <clip pos="1" side="tl" part="whole"/>
        <concat>
          <clip pos="1" side="tl" part="lem"/>
          <clip pos="1" side="tl" part="a_det"/>
          <lit-tag v="m"/>
          <lit-tag v="an"/>
          <lit-tag v="sg"/>
          <lit-tag v="nom"/>
        </concat>
      </let>
    </def-macro>

    <def-macro n="adapt-num" npar="1">
      <!-- arg.1 numeral -> numeral
           Set the numeral to the default <nom>. Other tags are taken from the bidix.
           INPUT: ^бер<num>/один<num><m><an><sg>$ "OUTPUT": ^бер<num>/^один<num><m><an><sg><nom$
           INPUT: ^1<num>/1<num><digit>$ "OUTPUT": ^1<num>/^1<num>$ -->
      <choose>
        <when>
          <test><equal><clip pos="1" side="tl" part="a_digit"/><lit-tag v="digit"/></equal></test>
          <let>
            <clip pos="1" side="tl" part="whole"/>
            <concat>
              <clip pos="1" side="tl" part="lem"/>
              <clip pos="1" side="tl" part="a_num"/>
            </concat>
          </let>
        </when>
        <otherwise>
          <let>
            <clip pos="1" side="tl" part="whole"/>
            <concat>
              <clip pos="1" side="tl" part="lem"/>
              <clip pos="1" side="tl" part="a_num"/>
              <clip pos="1" side="tl" part="a_gender"/>
              <clip pos="1" side="tl" part="a_anim"/>
              <clip pos="1" side="tl" part="a_nbr"/>
              <lit-tag v="nom"/>
            </concat>
          </let>
        </otherwise>
      </choose>
    </def-macro>

    <def-macro n="translate-verb-fin" npar="1">
      <!-- arg.1 finiteVerb -> v_negation finiteVerb
           Converts negation, tenses and features related to it (such as gender
           in the past tense). Strips transitivity tag (rus.dix doesn't support it yet).
           GIVEN:  ^уйна<v><tv><pres><p1><sg>/играть<vblex><impf><tv><pres><p1><sg>$
           EXPECT: ^уйна<v><tv><pres><p1><sg>/играть<vblex><impf><pres><p1><sg>$
           GIVEN:  ^уйна<v><tv><neg><ifi><p3><pl>/играть<vblex><impf><tv><neg><ifi><p3><pl>$
           EXPECT: ^уйна<v><tv><neg><ifi><p3><pl>/играть<vblex><impf><past><mfn><pl>$ negation='не<adv>' -->
      <let><var n="gender"/><lit v=""/></let>
      <call-macro n="convert-neg-to-ne.adv">
        <with-param pos="1"/>
      </call-macro>
      <choose>
        <when>
          <test><equal><clip pos="1" side="sl" part="a_tense"/><lit-tag v="ifi"/></equal></test>
          <let><clip pos="1" side="tl" part="a_tense"/><lit-tag v="past"/></let>
        </when>
      </choose>
      <choose>
        <when>
          <test>
            <and>
              <equal><clip pos="1" side="tl" part="a_tense"/><lit-tag v="past"/></equal>
              <equal><clip pos="1" side="tl" part="a_nbr"/><lit-tag v="pl"/></equal>
            </and>
          </test>
          <let><var n="gender"/><lit-tag v="mfn"/></let>
          <let><clip pos="1" side="tl" part="a_pers"/><lit v=""/></let> <!-- no person in past tense in Russian -->
        </when>
        <when>
          <test>
            <and>
              <equal><clip pos="1" side="tl" part="a_tense"/><lit-tag v="past"/></equal>
              <not><equal><clip pos="1" side="tl" part="a_nbr"/><lit-tag v="pl"/></equal></not>
            </and>
          </test>
          <let><var n="gender"/><lit-tag v="m"/></let>
          <let><clip pos="1" side="tl" part="a_pers"/><lit v=""/></let> <!-- no person in past tense in Russian -->
        </when>
      </choose>
      <let>
        <clip pos="1" side="tl" part="whole"/>
        <concat>
            <clip pos="1" side="tl" part="lemh"/>
            <clip pos="1" side="tl" part="a_vblex"/>
            <clip pos="1" side="tl" part="a_tense"/>
            <var n="gender"/>
            <clip pos="1" side="tl" part="a_pers"/>
            <clip pos="1" side="tl" part="a_nbr"/>
            <clip pos="1" side="tl" part="lemq"/>
        </concat>
      </let>
    </def-macro>

    <def-macro n="concord2" npar="2">
      <!-- arg.1 determiner arg.2 noun -> determiner noun
           Concords gender, animacy, number, case of the determiner with the head of the NP.
           Assumes that the head of the NP was already 'translated'. -->

      <!-- "First, copy everything except for animacy from the noun (for some reason some of the
           possessive determiners do not receive animacy tag in rus.dix)."-->
      <let>
        <clip pos="1" side="tl" part="whole"/>
        <concat>
          <clip pos="1" side="tl" part="lem"/>
          <clip pos="1" side="tl" part="a_det"/>
          <clip pos="2" side="tl" part="a_gender"/>
          <clip pos="1" side="tl" part="a_anim"/>
          <clip pos="2" side="tl" part="a_nbr"/>
          <clip pos="2" side="tl" part="a_case"/>
        </concat>
      </let>
      <!-- Now adjust -->
      <choose>
        <when>
          <test><equal><clip pos="1" side="tl" part="a_nbr"/><lit-tag v="pl"/></equal></test>
          <let><clip pos="1" side="tl" part="a_gender"/><lit-tag v="mfn"/></let>
        </when>
      </choose>
      <choose>
        <when c="If the gender is masculin or number is plural, in accusative we want to take the
                 animacy tag of the noun, otherwise it should be set to 'an'.">
          <test>
            <and>
              <or>
                <equal><clip pos="1" side="tl" part="a_gender"/><lit-tag v="m"/></equal>
                <equal><clip pos="1" side="tl" part="a_gender"/><lit-tag v="mfn"/></equal>
              </or>
              <equal><clip pos="1" side="tl" part="a_case"/><lit-tag v="acc"/></equal>
            </and>
          </test>
          <let><clip pos="1" side="tl" part="a_anim"/><clip pos="2" side="tl" part="a_anim"/></let>
        </when>
        <otherwise>
          <let><clip pos="1" side="tl" part="a_anim"/><lit-tag v="an"/></let>
        </otherwise>
      </choose>
    </def-macro>

  </section-def-macros>

  <section-rules>

<!--
INPUT:  мәктәп
        ^мәктәп<n><nom>$
OUTPUT: школа
        ^noun<NP>{^школа<n><m><nn><sg><nom$}$
-->
    <rule comment="">
      <pattern>
        <pattern-item n="noun"/>
      </pattern>
      <action>
        <call-macro n="translate-noun">
          <with-param pos="1"/>
        </call-macro>
        <out>
          <chunk name="noun" case="caseFirstWord">
            <tags>
              <tag><lit-tag v="NP"/></tag>
            </tags>
            <var n="preposition"/>
            <lu>
              <clip pos="1" side="tl" part="whole"/>
            </lu>
          </chunk>
        </out>
      </action>
    </rule>

<!--
INPUT:  ^Өй<n><attr>/Дом<n><m><nn><attr>$ ^алд<n><px3sp><loc>/перед<pr>$
OUTPUT: ^pr_noun<PP><ADVL>^Перед<pr>$ ^дом<n><m><nn><sg><ins>$
-->
    <rule comment="REGLA:">
      <pattern>
        <pattern-item n="noun-attr"/>
        <pattern-item n="nounpost"/>
      </pattern>
      <action>
        <call-macro n="return-case-pr-governs">
          <with-param pos="2"/>
        </call-macro>
        <out>
          <chunk name="pr_noun" case="caseFirstWord">
            <tags>
              <tag><lit-tag v="PP"/></tag>
            </tags>
            <lu>
              <clip pos="2" side="tl" part="whole"/>
            </lu>
            <b/>
            <lu>
              <clip pos="1" side="tl" part="lem"/>
              <clip pos="1" side="tl" part="a_noun"/>
              <clip pos="1" side="tl" part="a_gender"/>
              <clip pos="1" side="tl" part="a_anim"/>
              <lit-tag v="sg"/>
              <var n="case"/>
            </lu>
          </chunk>
        </out>
      </action>
    </rule>

<!--
INPUT:  ^өй<n><attr>/дом<n><m><nn><attr>$ ^алд<n><px3sp><loc><attr>/перед<pr><attr>$
        ^бакча<n><loc>/сад<n><m><nn><loc>$
OUTPUT: ^noun_pr_noun<NP>{сад<n><m><nn><sg><nom> ^перед<pr>$ ^дом<n><m><nn><sg><ins>$}$
-->
    <rule comment="REGLA:">
      <pattern>
        <pattern-item n="noun-attr"/>
        <pattern-item n="nounpost-attr"/>
        <pattern-item n="noun-loc"/>
      </pattern>
      <action>
        <call-macro n="return-number-of-sl-noun">
          <with-param pos="3"/>
        </call-macro>
        <call-macro n="return-case-pr-governs">
          <with-param pos="2"/>
        </call-macro>
        <out>
          <chunk name="noun_pr_noun" case="caseFirstWord">
            <tags>
              <tag><lit-tag v="NP"/></tag>
            </tags>
            <lu>
              <lit v="в"/>
              <lit-tag v="pr"/>
            </lu>
            <b/>
            <lu>
              <clip pos="3" side="tl" part="lem"/>
              <clip pos="3" side="tl" part="a_noun"/>
              <clip pos="3" side="tl" part="a_gender"/>
              <clip pos="3" side="tl" part="a_anim"/>
              <lit-tag v="sg"/>
              <lit-tag v="prp"/>
            </lu>
            <b/>
            <lu>
              <clip pos="2" side="tl" part="lem"/>
              <clip pos="2" side="tl" part="a_pr"/>
            </lu>
            <b/>
            <lu>
              <clip pos="1" side="tl" part="lem"/>
              <clip pos="1" side="tl" part="a_noun"/>
              <clip pos="1" side="tl" part="a_gender"/>
              <clip pos="1" side="tl" part="a_anim"/>
              <lit-tag v="sg"/>
              <var n="case"/>
            </lu>
          </chunk>
        </out>
      </action>
    </rule>

<!--
INPUT:  Гөлнараның эте юк
        ^Гөлнара<np><ant><f><gen>$ ^эт<n><px3sp><nom>$ ^юк<adj>$ ^и<cop><p3><sg>
OUTPUT: У Гульнары нет собаки
        ^bar-yuq<S>{^У<pr>$ ^Гульнара<np><ant><f><sg><gen>$ ^быть<vbser><neg><pres><p3><sg>$ ^собака<n><f><aa><sg><gen>$}$
-->
    <rule comment="">
      <pattern>
        <pattern-item n="noun-gen"/>
        <pattern-item n="noun-px3sp-nom"/>
        <pattern-item n="yuq-adj"/>
        <pattern-item n="cop-p3"/>
      </pattern>
      <action>
        <out>
          <chunk name="bar-yuq">
            <tags>
              <tag><lit-tag v="S"/></tag>
            </tags>
            <lu>
              <lit v="у"/>
              <lit-tag v="pr"/>
            </lu>
            <b/>
            <lu>
              <clip pos="1" side="tl" part="lem"/>
              <clip pos="1" side="tl" part="a_noun"/>
              <clip pos="1" side="tl" part="a_gender"/>
              <clip pos="1" side="tl" part="a_anim"/>
              <clip pos="1" side="tl" part="a_nbr"/>
              <lit-tag v="gen"/>
            </lu>
            <b/>
            <lu>
              <clip pos="3" side="tl" part="whole"/>
            </lu>
            <b/>
            <lu>
              <clip pos="2" side="tl" part="lem"/>
              <clip pos="2" side="tl" part="a_noun"/>
              <clip pos="2" side="tl" part="a_gender"/>
              <clip pos="2" side="tl" part="a_anim"/>
              <lit-tag v="sg"/>
              <lit-tag v="gen"/>
            </lu>
          </chunk>
        </out>
      </action>
    </rule>

<!--
INPUT:  ^и<cop><p3><sg>/быть<vbser><p3><sg>$
OUTPUT: ^cop-pres<VBSER>{^быть<vbser><pres><p3><sg>$}$
-->
    <rule comment="">
      <pattern>
        <pattern-item n="cop-pres"/>
      </pattern>
      <action>
        <call-macro n="convert-neg-to-ne.adv">
          <with-param pos="1"/>
        </call-macro>
        <choose>
          <when>
            <test><not><equal><var n="negation"/><lit v=""/></equal></not></test>
          </when>
        </choose>
        <out>
          <chunk name="cop-pres">
            <tags>
              <tag><lit-tag v="VBSER"/></tag>
            </tags>
            <var n="negation"/>
            <b/>
            <lu>
              <clip pos="1" side="tl" part="lem"/>
              <clip pos="1" side="tl" part="a_vbser"/>
              <lit-tag v="pres"/>
              <clip pos="1" side="tl" part="a_pers"/>
              <clip pos="1" side="tl" part="a_nbr"/>
            </lu>
          </chunk>
        </out>
      </action>
    </rule>

<!--
INPUT:  ^и<cop><ifi><p3><sg>/быть<vbser><ifi><p3><sg>
OUTPUT: ^cop<VBSER>{^быть<vbser><past><nt><sg>$}$
-->
    <rule comment="">
      <pattern>
        <pattern-item n="cop-ifi"/>
      </pattern>
      <action>
        <out>
          <chunk name="cop">
            <tags>
              <tag><lit-tag v="VBSER"/></tag>
            </tags>
            <lu>
              <clip pos="1" side="tl" part="lem"/>
              <clip pos="1" side="tl" part="a_vbser"/>
              <lit-tag v="past"/>
              <lit-tag v="nt"/>
              <clip pos="1" side="tl" part="a_nbr"/>
            </lu>
          </chunk>
        </out>
      </action>
    </rule>

<!--
INPUT:  ^уйна<v><tv><pres><p1><sg>/играть<vblex><impf><tv><pres><p1><sg>$
OUTPUT: ^verb<VBLEX>{^играть<vblex><impf><pres><p1><sg>$}$
INPUT:  ^уйна<v><tv><neg><ifi><p3><pl>/играть<vblex><impf><tv><neg><ifi><p3><pl>$
OUTPUT: ^verb<VBLEX>{^не/не<adv>$ ^играли/играть<vblex><impf><past><mfn><pl>$}$
-->
    <rule comment="">
      <pattern>
        <pattern-item n="verb-fin"/>
      </pattern>
      <action>
        <call-macro n="translate-verb-fin">
          <with-param pos="1"/>
        </call-macro>
        <out>
          <chunk name="verb">
            <tags>
              <tag><lit-tag v="VBLEX"/></tag>
            </tags>
            <var n="negation"/>
            <b/>
            <lu>
              <clip pos="1" side="tl" part="whole"/>
            </lu>
          </chunk>
        </out>
      </action>
    </rule>

<!--
INPUT:  ^уйна<v><tv><ger_past><px3sp><acc>/игра<n><f><nn><px3sp><acc> 
OUTPUT: ^noun<NP>{^игра<n><f><nn><acc>$}$
INPUT:  ^и<cop><ger_past><px3sp><acc>/быть<vbser><ger_past><px3sp><acc>$
OUTPUT: ^inf<VBLEX>{^быть<vbser><inf>$}$
INPUT:  ^тап<v><tv><prc_impf>/найти<vblex><perf><tv><prc_impf>$ (алмый/не может)
OUTPUT: ^inf<VBLEX>{^найти<vblex><perf><inf>$}$
-->
    <rule comment="To translate every non-finite form with infinitive is not good,
                   but this is a temporal solution until things get sorted out.">
      <pattern>
        <pattern-item n="verb-nonfin"/>
      </pattern>
      <action>
        <choose>
          <when>
            <test><equal><clip pos="1" side="tl" part="a_noun"/><lit-tag v="n"/></equal></test>
            <call-macro n="translate-noun">
              <with-param pos="1"/>
            </call-macro>
            <out>
              <chunk name="noun">
                <tags>
                  <tag><lit-tag v="NP"/></tag>
                </tags>
                <lu>
                  <clip pos="1" side="tl" part="whole"/>
                </lu>
              </chunk>
            </out>
          </when>
          <otherwise>
            <call-macro n="convert-neg-to-ne.adv">
              <with-param pos="1"/>
            </call-macro>
            <out>
              <chunk name="inf">
                <tags>
                  <tag><lit-tag v="VBLEX"/></tag>
                </tags>
                <var n="negation"/>
                <b/>
                <lu>
                  <clip pos="1" side="tl" part="lemh"/>
                  <clip pos="1" side="tl" part="a_vblex"/><!-- OR --><clip pos="1" side="tl" part="a_vbser"/>
                  <lit-tag v="inf"/>
                  <clip pos="1" side="tl" part="lemq"/>
                </lu>
              </chunk>
            </out>
          </otherwise>
        </choose>
      </action>
    </rule>

<!--
INPUT:  (^бел<v><tv><pres><p2><pl>/знать<vblex><impf><tv><pres><p2><pl>$)
        ^мы<qst>/@мы<qst>$^?<sent>/?<sent>$
OUTPUT: ^qst<SENT>{^?<sent>$}$
-->
    <rule comment="">
      <pattern>
        <pattern-item n="qst"/>
        <pattern-item n="sent"/>
      </pattern>
      <action>
        <out>
          <chunk name="qst">
            <tags>
              <tag><lit-tag v="SENT"/></tag>
            </tags>
            <lu>
              <clip pos="2" side="tl" part="whole"/>
            </lu>
          </chunk>
        </out>
      </action>
    </rule>

<!--
INPUT:  ^мин<prn><pers><p1><sg><gen>/мой<det><pos><m><an>$ ^бакча<n><px1sg><nom>/сад<n><m><nn><px1sg><nom>$
OUTPUT: ^det_noun<NP>{мой<det><pos><m><nn><sg><nom>$ ^сад<n><m><nn><sg><nom>$}$
-->
    <rule comment="">
      <pattern>
        <pattern-item n="prn-gen"/>
        <pattern-item n="noun-px"/>
      </pattern>
      <action>
        <choose>
          <when c="n.px3sp.{dat/abl/loc} is translated with a preposition">
            <test><equal><clip pos="2" side="tl" part="a_pos"/><lit-tag v="pr"/></equal></test>
            <out>
              <chunk name="pr">
                <tags>
                  <tag><lit-tag v="PREP"/></tag>
                </tags>
                <lu>
                  <clip pos="2" side="tl" part="whole"/>
                </lu>
              </chunk>
              <b/>
              <chunk name="noun">
                <tags>
                  <tag><lit-tag v="NP"/></tag>
                </tags>
                <lu>
                  <clip pos="1" side="tl" part="whole"/>
                </lu>
              </chunk>
            </out>
          </when>
          <otherwise>
            <call-macro n="translate-noun">
              <with-param pos="2"/>
            </call-macro>
            <call-macro n="concord2">
              <with-param pos="1"/>
              <with-param pos="2"/>
            </call-macro>
            <choose>
              <when c="'его' and 'их' do not take animacy or gender tags">
                <test>
                  <or>
                    <equal caseless="yes"><clip pos="1" side="tl" part="lem"/><lit v="его"/></equal>
                    <equal caseless="yes"><clip pos="1" side="tl" part="lem"/><lit v="их"/></equal>
                  </or>
                </test>
                <out>
                  <chunk name="det_noun">
                    <tags>
                      <tag><lit-tag v="NP"/></tag>
                    </tags>
                    <var n="preposition"/>
                    <lu>
                      <clip pos="1" side="tl" part="lem"/>
                      <clip pos="1" side="tl" part="a_det"/>
                    </lu>
                    <b/>
                    <lu>
                      <clip pos="2" side="tl" part="whole"/>
                    </lu>
                  </chunk>
                </out>
              </when>
              <otherwise c="all other possessive determiners">
                <out>
                  <chunk name="det_noun">
                    <tags>
                      <tag><lit-tag v="NP"/></tag>
                    </tags>
                    <var n="preposition"/>
                    <lu>
                      <clip pos="1" side="tl" part="whole"/>
                    </lu>
                    <b/>
                    <lu>
                      <clip pos="2" side="tl" part="whole"/>
                    </lu>
                  </chunk>
                </out>
              </otherwise>
            </choose>
          </otherwise>
        </choose>
      </action>
    </rule>

<!--
INPUT:  ^абый<n><px1sg><dat>/брат<n><m><aa><px1sg><dat>$  
OUTPUT: ^noun<NP>{^мой<det><pos><m><an><sg><dat>$ ^брат<n><m><aa><sg><dat>$}$
-->
    <rule comment="TODO: det.pos insertion doesn't work yet">
      <pattern>
        <pattern-item n="noun-px"/>
      </pattern>
      <action>
        <choose>
          <when c="sometimes Tatar noun with px3sp is translated with a preposition">
            <test><equal><clip pos="1" side="tl" part="a_pr"/><lit-tag v="pr"/></equal></test>
          <out>
            <chunk name="pr" case="caseFirstWord">
              <tags>
                <tag><lit-tag v="PREP"/></tag>
              </tags>
              <lu>
                <clip pos="1" side="tl" part="whole"/>
              </lu>
            </chunk>
          </out>
          </when>
          <otherwise>
            <call-macro n="translate-noun">
              <with-param pos="1"/>
            </call-macro>
            <out>
              <chunk name="noun" case="caseFirstWord">
                <tags>
                  <tag><lit-tag v="NP"/></tag>
                </tags>
                <var n="preposition"/>
                <lu>
                  <clip pos="1" side="tl" part="whole"/>
                </lu>
              </chunk>
            </out>
          </otherwise>
        </choose>
      </action>
    </rule>

<!--
INPUT:  ^яхшы<adj>/хороший<adj>$
OUTPUT: ^adj<AdjP>{^хороший<adj><m><an><sg><nom$}$
-->
    <rule comment="">
      <pattern>
        <pattern-item n="adj"/>
      </pattern>
      <action>
        <choose>
          <when>
            <test><equal><clip pos="1" side="tl" part="a_adv"/><lit-tag v="adv"/></equal></test>
            <out>
              <chunk name="adv">
                <tags>
                  <tag><lit-tag v="AdvP"/></tag>
                </tags>
                <lu>
                  <clip pos="1" side="tl" part="whole"/>
                </lu>
              </chunk>
            </out>
          </when>
          <when>
            <test><equal caseless="yes"><clip pos="1" side="tl" part="lem"/><lit v="быть"/></equal></test>
            <out>
              <chunk name="bar">
                <tags>
                  <tag><lit-tag v="VBSER"/></tag>
                </tags>
                <lu>
                  <clip pos="1" side="tl" part="whole"/>
                </lu>
              </chunk>
            </out>
          </when>
          <when>
            <test><equal><clip pos="1" side="tl" part="a_pos"/><lit-tag v="pred"/></equal></test>
            <out>
              <chunk name="pred">
                <tags>
                  <tag><lit-tag v="PRED"/></tag>
                </tags>
                <lu>
                  <clip pos="1" side="tl" part="lem"/>
                  <lit-tag v="pred"/>
                  <lit-tag v="m"/>
                  <lit-tag v="sg"/>
                </lu>
              </chunk>
            </out>
          </when>
          <otherwise>
            <out>
              <chunk name="adj">
                <tags>
                  <tag><lit-tag v="AdjP"/></tag>
                </tags>
                <lu>
                  <clip pos="1" side="tl" part="lem"/>
                  <clip pos="1" side="tl" part="a_adj"/>
                  <lit-tag v="m"/>
                  <lit-tag v="an"/>
                  <lit-tag v="sg"/>
                  <lit-tag v="nom"/>
                </lu>
              </chunk>
            </out>
          </otherwise>
        </choose>
      </action>
    </rule>

<!--
INPUT: ^бер<num>/один<num><m><an><sg>$ OUTPUT: ^det<DET>{^один<num><m><an><sg><nom>$}$
INPUT: ^бер<det><ind>/один<num><num><m><an><sg>$ OUTPUT: ^det<DET>{^один<num><m><an><sg><nom>$}$
-->
    <rule comment="Digits receive only the 'num' tag in rus.dix. In order to be able to distinguish
                   whether the lemma is a digit or not, for digits we add an additional 'digit' tag
                   in bidix, which we delete here (i.e. do not output it).">
      <pattern>
        <pattern-item n="det"/>
      </pattern>
      <action>
        <call-macro n="adapt-det">
          <with-param pos="1"/>
        </call-macro>
        <out>
          <chunk name="det">
            <tags>
              <tag><lit-tag v="DET"/></tag>
            </tags>
            <lu>
              <clip pos="1" side="tl" part="whole"/>
            </lu>
          </chunk>
        </out>
      </action>
    </rule>

<!--
INPUT: ^бер<num>/один<num><m><an><sg>$ OUTPUT: ^det<DET>{^один<num><m><an><sg><nom>$}$
INPUT: ^бер<det><ind>/один<num><num><m><an><sg>$ OUTPUT: ^det<DET>{^один<num><m><an><sg><nom>$}$
-->
    <rule comment="Digits receive only the 'num' tag in rus.dix. In order to be able to distinguish
                   whether the lemma is a digit or not, for digits we add an additional 'digit' tag
                   in bidix, which we delete here (i.e. do not output it).">
      <pattern>
        <pattern-item n="num"/>
      </pattern>
      <action>
        <call-macro n="adapt-num">
          <with-param pos="1"/>
        </call-macro>
        <out>
          <chunk name="num">
            <tags>
              <tag><lit-tag v="DET"/></tag>
            </tags>
            <lu>
              <clip pos="1" side="tl" part="whole"/>
            </lu>
          </chunk>
        </out>
      </action>
    </rule>

<!--
INPUT:  ^урындык<n><attr>/стул<n><m><nn><attr>$ ^аст<n><pl><px3sp><acc>/низ<n><m><nn><sg><nom><pl><px3sp><acc>$
OUTPUT: ^noun_noun-gen<NP>{^низ<n><m><nn><pl><acc>$ ^стул<n><m><nn><pl><gen>$}$
-->
    <rule comment="">
      <pattern>
        <pattern-item n="noun-attr"/>
        <pattern-item n="noun-px3sp"/>
      </pattern>
      <action>
        <call-macro n="translate-noun">
          <with-param pos="2"/>
        </call-macro>
        <out>
          <chunk name="noun_noun-gen">
            <tags>
              <tag><lit-tag v="NP"/></tag>
            </tags>
            <var n="preposition"/>
            <lu>
              <clip pos="2" side="tl" part="whole"/>
            </lu>
            <b/>
            <lu>
              <clip pos="1" side="tl" part="lem"/>
              <clip pos="1" side="tl" part="a_noun"/>
              <clip pos="1" side="tl" part="a_gender"/>
              <clip pos="1" side="tl" part="a_anim"/>
              <clip pos="2" side="tl" part="a_nbr"/>
              <lit-tag v="gen"/>
            </lu>
          </chunk>
        </out>
      </action>
    </rule>

  </section-rules>

</transfer>
